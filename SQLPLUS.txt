1. 데이터베이스 & DBMS
    - 방대한 데이터를 효율적으로 관리하게 위해 컴퓨터에 통합, 저장한 것
    - 특정 조직의 여러 사용자가 공유하여 사용할 수 있도록 통합해서 저장한 운영 
      데이터의 집합
    - 데이터베이스 관리 시스템이라는 프로그램을 이용하여 관리

    (1) DB에 저장된 데이터의 특징
        1) 공유 데이터(Shared Data)
        2) 통합 데이터(Integrated Data)
            - 최소의 중복과 통제 가능한 중복만 허용하는 데이터
        3) 저장 데이터 (Stored Data)
        4) 운영 데이터 (Operational Data)

    (2) DBMS 운영 방식
        1) 로컬 DB - 나 혼자 쓰는 DB
            -Access, Sqlite, ...
        2) 네트워크 DB - 여러 명이 같이 사용하는 DB
            - Oracle, SqlServer, DB2, MySQL, MariaDB, Informix ...
        
    (3) 학습 대상
        1) Administrator(관리자)
        2) Developer(개발자)

    (4) 저장 형태에 따른 구분
        1) 계층형 DB(HDB) - tree
        2) 네트워크형 DB(NDB) - graph
        3) 관계형 DB(RDB) - table (*)
            - 필드를 합쳐서 레코드가 됨
            - 테이블은 행과 열로 구성; 각 행은 레코드를 나타냄
            - 테이블부터 파일로 저장 가능; 레코드부터는 메모리로만 저장됨
            DB > table > record > field
        4) 객체 지향형 DB
        5) 객체 관계형 DB

    (5) 용어
        1) Data Persistence
        2) Dataware House: 정보에 입각한 의사 결정을 내릴 수 있도록 분석 가능한 
                           정보의 저장소
        3) Data Mining: 대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 
                        규칙이나 패턴을 찾아내는 것
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
2. DBMS 설치
    (1) 제어판 - 서비스 확인
    (2) 원격 접속 프로그램(클라이언트 유틸리티)
        1)무료: Sqldeveloper=> 윈도우용(마우스만 가지고도 가능), Sqlplus=> 콘솔용(명령어를 알아야함)
        Sqlplus - Oracle깔면서 자동으로 깔림
        2)유료: Toad, Sqlgate, ...

    (3) Sqlplus
        1) 접속
            Sqlplus
            아이디:
            패스워드:
            Sqlplus 아이디/패스워드 -> 단점: 패스워드 노출
            Sqlplus 아이디 enter -> 패스워드 입력

            Sqlplus 사용자id/패스워드@host명

            접속을 끊지 않은 상태에서 다른 사용자 접속
            명령어: conn 아이디/패스워드; 유저 변경
            show user; 현재 유저를 보여줌

    (4) Sample 계정: scott
        - @C:\oraclexe\app\oracle\product\11.2.0\server\rdbms\admin\scott.sql
        - alter user scott identified by 패스워드;
            스캇 유저 계정 비번 변경
            scott이란 oracle에서 만든 샘플 계정;

        - 예를 들어 사용자 test1 추가
            create user test1 identified by 패스워드;

        select * from tab; 현재 사용자가 어떤 테이블을 관리할 수 있는지 보여줌

    (5) 계정 관리
        - 예를 들어 사용자 test1 추가
            create user test1 identified by 패스워드;

        - 접속 권한 부여
            관리자 접속
            grant connect to test1; test1사용자에게 접속할 수 있는 권한 부여

        - 관리자 비번 분실
           명령어: system as sysdba
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
3.SQL(Structured Query Language)
    -관계형 데이터베이스의 조작과 관리에 사용되는 데이터베이스 질의용 언어
    - 원하는 데이터가 무엇인지만 기술하는 비절차적 언어
    - 인터프리터 방식
    - 표준 문법(ANSI SQL), 비표준 문법

        (1) SQL 분류
            1) DDL (Data Definition Language)
                - 데이터 정의어
                - 데이터베이스 개체를 생성/삭제/변경하는 역할
                - CREATE, DROP, ALTER
            2) DML (Data Manipulation Language)
                - 데이터 조작어
                - DB의 기본 연산인 CRUD를 할 수 있는 언어
                - INSERT, UPDATE, DELETE, SELECT
            3) DCL (Data Control Language)
                - 데이터 제어어
                - DB를 관리(권한 부여, 권한 제어, 분산처리, 백업, 복원, ...)
            4) QL (QUERY LANGUAGE)
                -SELECT

        (2) SELECT 문법
            select * from tab; 현재 사용자가 사용할 수 있는 테이블 조회
            DESC 테이블명; 테이블의 예시적인 구조 설명
            DESC emp; 젤 많이 쓸 샘플 명령어

            EMPNO   직원번호; id값                     NOT NULL NUMBER(4)
            ENAME   직원 이름; 10자 문자열 저장;                 VARCHAR2(10)
            JOB     직원의 업무; 9자 문자열 저장 ;               VARCHAR2(9)
            MGR     직원의 관리자(상사)를 나타냄                 NUMBER(4)
            HIREDATE       직원의 입사일;                       DATE
            SAL    직원의 월급; 7자리 숫자 표현, 소수점 이하 2자리까지 저장   
                                                               NUMBER(7,2)
            COMM   커미션(보너스)                               NUMBER(7,2)
            DEPTNO   부서번호; 해당 직원이 속한 부서의 식별번호   NUMBER(2)

            1) 기본 문법
                SELECT 필드명, ... FROM [소유자].테이블명
                ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
                SELECT empno, ename, job, mgr FROM scott.emp;내가 보고싶은 데이터 검색;
                본인일 때는 소유자명 생략 가능, 관리자급이나 권한 부여된 사용자는 소유자명 반드시 입력;

                SELECT * FROM 테이블명; 모든필드 조회 (*=전부)

                필드의 가공처리
                ㅡㅡㅡㅡㅡㅡㅡㅡ
                사원의 사번, 이름, 급여를 조회하시오.
                단, 급여는 현재 급여에 100$ 추가하여 조회
                SELECT empno, ename, sal, sal+100 FROM emp;

                필드에 alias(별명) 부여 가능; 필드명 대신 부여한 별명으로 대신해줌
                필드명 별명 or 필드명 AS 별명
                ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
                SELECT empno, ename, sal 급여, sal+100 AS "100$ 추가된 급여" FROM emp;
                ""로 묶어주면 띄어쓰기 입력 가능;

                중복된 값 제거: distinct
                ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
                이 회사에 어떤 업무가 있는가?
                SELECT DISTINCT job FROM emp; SELECT 앞에 쓰면 중복 값 제거해줌

            2) 확장 문법
                - 정렬 기능
                    ORDER BY 필드명[, 필드명, ...] [ASC(오름차순) | DESC(내림차순)]
                    ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
                    급여가 많은 순으로 사번, 이름, 급여를 조회
                    SELECT empno, ename, sal FROM emp 
                    ORDER BY sal DESC;

                    부서별로 급여가 적은 순으로 이름, 급여, 부서번호를 조회하시오
                    SELECT ename, sal, deptno FROM emp ORDER BY deptno, sal;
                    기본적으로 정렬에서 아무설정 안하면 ASC(오름차순);
                **************************************************************

                - 조건 기능(레코드 필터링)
                    WHERE 조건식
                    기본 연산자: >,<,>=,<=,=(sql에서는 '='하나만써도 같다라는 뜻)
                                !=, <> => 같지 않다라는 뜻
                    논리 연산자: and, or, not
                    SQL 연산자: between and, in, is null, is not null, like, ...
                    ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
                    * 급여가 3000$ 이상인 직원의 사번, 이름, 급여를 조회
                    단, 급여가 많은 순으로 조회
                    SELECT empno, ename, sal FROM emp WHERE sal >= 3000 ORDER BY sal DESC;
                    * ORDER BY는 항상 마지막에 작성; 정렬기능이기 때문

                    * 업무가 manager인 사원의 이름, 부서, 업무, 급여를 조회
                    SELECT ename, deptno, job, sal FROM emp 
                    WHERE job='MANAGER';

                    * 1982년 1월 1일 이후에 입사한 직원의 이름, 부서, 입사일자 조회
                    SELECT ename, deptno, hiredate FROM emp 
                    WHERE hiredate >= '82/01/01'; 날짜의 경우 자동변환, /., 등등 다 호환됨

                    * 부서가 20이고 업무가 analyst인 직원의 이름, 부서, 입사 일자 조회
                    SELECT ename, deptno, hiredate FROM emp 
                    WHERE deptno = 20 AND job = 'ANALYST'; 숫자는 ''안붙임, 대문자 소문자 구별;

                    * 급여가 1500 이상 2500 이하를 받는 직원의 이름,부서, 업무, 급여를 조회
                    SELECT ename, deptno, job, sal FROM emp 
                    WHERE sal >= 1500 AND sal <= 2500;

                    SELECT ename, deptno, job, sal FROM emp 
                    WHERE sal BETWEEN 1500 AND 2500;

                    * 업무가 clerk, saleman, analyst인 직원의 이름, 부서, 업무를 조회
                    SELECT ename, deptno, job FROM emp 
                    WHERE job = 'CLERK' OR job = 'SALESMAN' OR job = 'ANALYST';
                    
                    SELECT ename, deptno, job FROM emp 
                    WHERE job 
                    IN('CLERK','SALESMAN','ANALYST');
                    IN= 같다라는 뜻에서만 쓸 수 있음

                    * 직원의 이름, 부서, 업무, 급여, 보너스를 조회
                    SELECT ename, deptno, job, sal, comm FROM emp;

                    * 커미션이 없는 직원의 이름, 부서, 업무, 급여, 커미션을 조회
                     SELECT ename, deptno, job, sal, comm FROM emp
                     WHERE comm is null;

                    * 커미션이 있는
                    SELECT ename, deptno, job, sal, comm FROM emp 
                    WHERE comm is not null;

                    SELECT ename, deptno, job, sal, comm FROM emp 
                    WHERE job = 'SALESMAN';

                    *like 연산자
                        %: 0개 이상의 문자를 대체할 때 사용
                        _: 1개의 문자를 대체
                        ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
                        beau%: beau로 시작하는 모든 단어
                        beau__: beau로 시작하는 2글자
                        %L%L%: L이 2개가 들어가는 단어

                    * 이름이 s로 시작하는 직원의 이름, 업무, 급여를 조회
                    SELECT ename, job, sal FROM emp WHERE ename like 'S%';
                **************************************************************

                - 그룹화
                    GROUP BY 필드명 [,필드명, ...] [HAVING 조건식]
                    * having은 group으로 묶었을 때만 사용할 수 있는 조건식임
                    * select에서의 where은 반드시 테이블 옆;
                    * where에 함수는 사용x; 함수 있을 때는 IN()으로 묶기;
                    ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
                    * 부서별로 급여 평균, 급여 합계, 최저 급여, 최대 급여 조회
                    SELECT deptno, avg(sal), sum(sal), min(sal), max(sal) FROM emp 
                    GROUP BY deptno; 그룹별로 묶어버리기

                    * 부서별로 급여평균, 최저급여를 조회.
                    단, 급여평균이 높은 순으로 조회
                    SELECT deptno, avg(sal), min(sal) FROM emp 
                    GROUP BY deptno 
                    ORDER BY avg(sal) DESC;

                    * 전체 급여의 합계가 5000을 초과하는 업무에 대해 급여 합계 조회
                    SELECT job, sum(sal) FROM emp 
                    GROUP BY job 
                    HAVING sum(sal) > 5000;
                    
                    * 전체 급여의 합계가 5000을 초과하는 업무에 대해 급여 합계 조회
                    단, salesman은 제외
                    SELECT job, sum(sal) FROM emp 
                    GROUP BY job 
                    HAVING sum(sal) > 5000
                    AND job != 'SALESMAN';

                    SELECT job, sum(sal) FROM emp 
                    WHERE job != 'SALESMAN'
                    GROUP BY job 
                    HAVING sum(sal) > 5000;
                    
        (3) Functions
            1) Single Row Function (단일 행 함수)
                - String Function
                    lower(), upper()
                    substr()
                    length()
                    instr()
                    ltrim(), rtrim(), trim()
                    translate(), replace()
                    chr(), ascii()
                ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
                    * 이름이 ford인 직원의 이름, 부서, 급여를 조회
                    단, 대소문자 구별없이 검색할 수 있도록 하기
                    SELECT ENAME, DEPTNO, SAL
                    FROM EMP
                    WHERE ename = upper('ford');

                    * 다음 주민번호에서 성별에 해당하는 것을 추출해라
                    SELECT substr('9012311234567',7,1) FROM dual;
                        저 숫자에서 7번째 있는 숫자부터 한글자를 뽑아와라
                    SELECT substr('9012311234567',7) FROM dual;
                        7번째 숫자 뒤로 전부;
                    *dual -> 가상의 테이블; 사용자가 필요한 값을 생성하는데 사용됨

                    * 문자열의 위치
                    instr('데이터','찾을 데이터',위치찾기)
                    SELECT instr('MILLER','L') FROM dual;
                        L이라는 문자가 몇번 째에 있는지

                    SELECT instr('MILLER','k') FROM dual;
                        oracle은 위치가 1부터 시작; 고로 k는 위치:0

                    SELECT instr('MILLER','L',1,1) FROM dual;
                        첫번째부터 찾아서 1번째 L의 위치를 가져옴

                    SELECT instr('MILLER','L',4,1) FROM dual;
                        4번째위치부터 찾기 시작해서 첫번째 L의 위치를 가져옴
                    
                    * 문자열의 재배치
                    translate('데이터','기존데이터','대체데이터')
                    SELECT translate('MILLER','L', '*') FROM dual;
                    L을 *로 바꿔줌; 위치파악 잘하기;

                    SELECT replace('MILLER','L', '*') FROM dual;

                    SELECT translate(sal, '0123456789','영일이삼사오육칠팔구') FROM emp;
                        translate의 경우 한글자,한글자를 바꿔줌

                    SELECT replace(sal, '0123456789','영일이삼사오육칠팔구') FROM emp; '0123456789' 이렇게 묶인 그 자체를 찾아서 바꿔줌

                    SELECT translate('JACK and JUE', 'J','BL') FROM dual;
                        translate는 단일행이라 B로만 바꿔줌

                    SELECT replace('JACK and JUE', 'J','BL') FROM dual;
                        문자 자체를 바꿔줌

        * 함수 정보
        https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Functions.html#GUID-D079EFD3-C683-441F-977E-2C9503089982

                - Numeric Function
                    round(), trunc(), floor(), ceil()
                    mod()
                    power()
                    sign()
                ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ       
                * 소숫점 자리수
                SELECT round(4567.678), round(4567.678,-2) FROM dual;
                    내가 원하는 자리에서 반올림

                SELECT trunc(4567.678), trunc(4567.678,-2) FROM dual;
                    내가 원하는 자리에서 버림 반환

                SELECT floor(4567.678) FROM dual;
                    무조건 내림

                SELECT ceil(4567.678) FROM dual;
                    무조건 올림

                - Datetime Function
                    sysdate; 현재날짜, 시간/ 시간은 생략됨;
                    months_between()
                    add_months()
                    next_day()
                    last_day()
                    round(), trunc(); 날짜데이터 반올림, 잘라내기 가능
                ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
                SELECT sysdate FROM dual;
                SELECT sysdate+100 FROM dual; 현재부터 100일 후

                SELECT months_between(sysdate, '2023/12/25') FROM dual;
                    현재 날짜와 두번째 날짜 데이터 사이에는 4개월정도 차이가 있음
                    입력값: -4.2448637; 월 단위임; 월이 안되면 소수점으로 나옴

                SELECT add_months(sysdate,4) FROM dual;
                    현재 날짜로부터 4개월을 더함;

                SELECT next_day('2023/7/7','금') FROM dual;
                    주어진 날짜에서 다음으로 특정 요일이 되는 날짜를 찾음

                SELECT last_day(sysdate) FROM dual;
                    현재 날짜나 주어진 날짜의 마지막 날이 언제인지

                SELECT round(sysdate) FROM dual;
                    12시가 지나면 반올림되서 다음날로 표기됨

                SELECT round('2023/8/16') FROM dual;
                    문자열이라 변환 안됨
                SELECT round(to_date('2023/8/16')) FROM dual;
                    to_date = 숫자로 변환해줌
                SELECT round(to_date('2023/8/16'),'MONTH') FROM dual;
                    'MONTH'를 붙이면 월단위로 반올림 해줌,'YEAR'은 년도로 반올림;

                - Conversion Function
                    cast()
                    to_date()
                    to_char()
                    to_number()
                ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
                SELECT ename, sal, to_char(sal) FROM emp;
                    to_char; 문자열로 바꿔줌
                SELECT ename, sal, to_char(sal,'$999,999') FROM emp;
                    문자열로 바꾸고 sal을 달러표시, 세자리씩 콤마를 찍겠다는 의미
                SELECT ename, sal, to_char(sal,'L999,999') FROM emp;
                    L은 원화 표시;
                SELECT ename, sal, to_char(sysdate,'YYYY MM DD HH: MI: SS') FROM emp; 현재 날짜를 두번째 데이터 형식으로 표현

                - Etc(기타)..
                    nvl(필드명, 대체할 값)
                    decode(필드명, 값, true, false); if else문
                    decode(필드명, 값, true, 값, true, 값, true, false);
                ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
                * 직원의 이름, 급여, 보너스, 총급여를 조회
                SELECT ename, sal, comm, (sal+nvl(comm,0)) AS 총급여 FROM emp;
                    nvl(); null값을 0으로 대체해서 계산할 수 있게 해줌

                * 현재 업무가 SALESMAN이면 "영업"이라고 출력하고 그렇지 않으면 
                  "일반"이라고 출력하시오.
                SELECT ename, decode(job, 'SALESMAN','영업','일 반') FROM emp;
                    이 업무가 세일즈맨과 같다면 영업 아니면 일반

            2) Aggregate Function (집계 함수) GROUP BY 구문과 함께 사용;
                sum(), avg(), max(), min(), count()
            ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
                * 직원이 총 몇명인가?
                SELECT count(empno) FROM emp;
                SELECT count(sal) FROM emp;
                x SELECT count(comm) FROM emp; null값이 아닌 것만 계산; 주의!
                SELECT count(*) FROM emp;
                    * -> 레코드의 열을 나타냄; 모든 레코드의 수를 셈;
                
            3) Analysis Function (분석 함수)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
4. Sqldeveloper 설치
    (1) JDK 설치
        제어판-> 시스템 보안-> 시스템-> 고급시스템 설정-> 환경변수-> 시스템변수 새로만들기-> JAVA_HOME-> ZULU17로 설정
    
    (2) Sqldeveloper 설치

    (3) HR 샘플
        - system으로 접속
        - ALTER USER hr ACCOUNT UNLOCK; 해당계정 락풀기
        - ALTER USER hr IDENTIFIED BY 1111; 비번 바꾸기
        - ALTER USER hr ACCOUNT UNLOCK IDENTIFIED BY 1111; 한번에
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
5. DML
    (1) INSERT
        INSERT INTO 테이블명(필드명,...) VALUES(값,...);
        INSERT INTO 테이블명 VALUES(값,...);

    (2) UPDATE
        UPDATE 테이블명
        SET 필드명= 값 [,필드명=값, ...]
        WHERE 조건문

    (3) DELETE
        DELETE FROM 테이블명 WHERE 조건문;
    ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
    *실습
        1) test1으로 접속해서 테이블 생성
            - 권한 부여(connection, resource)
                resource = 전체적인 권한;
                GRANT connent, resource TO test1; 권한 부여 명령어
            
            CREATE TABLE tbltest (
                id  number,
                name   varchar2(10),
                hiredate date
                );

        2) INSERT (데이터 추가)
            INSERT INTO (id, name, hiredate) VALUES(1, '홍길동', sysdate);
            INSERT INTO tbltest(id,name) VALUES(2, '임꺽정');
            INSERT INTO tbltest(id,name,hiredate) VALUES(3, '강감찬', null);
            INSERT INTO tbltest VALUES(4,'권율','22/8/1');

        3) UPDATE (데이터 수정)
            UPDATE tbltest
            SET name = '신돌석'
            WHERE id=3;

            UPDATE tbltest
            SET hiredate=sysdate, name='유비'
            WHERE name='임꺽정';

        4) DELETE
            DELETE FROM tbltest WHERE id=3;
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
6. Sub Query
    (1) 다른 Query문 안에 포함된 Query문
    (2) 반드시 ()를 사용
    (3) ORDER BY를 사용할 수 없음

    (4) 유형
        1) 단일행 (Single Row)
        2) 다중행
        3) 다중열

    (5) 연산자
        1) 단일행 연산자
            - 기본 연산자 (산술, 비교, 논리)
        2) 다중행 연산자
            - in(=), any(or 연산자), all(and 연산자), exists, not

    (6) 상관 Sub Query
        - 구별하기 위해 별명 생성(e); 별명 있는 것이 상관 서브쿼리;

    ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
    * Ford의 급여보다 더 많이 받는 직원의 이름, 업무, 급여를 조회
    SELECT sal FROM emp 
    WHERE ename='FORD'; 3000달러
    SELECT ename, job, sal FROM emp 
    WHERE sal > 3000;

    SELECT ename, job, sal FROM emp 
    WHERE sal > (SELECT sal FROM emp WHERE ename='FORD');
    위쪽 화살표 연산자의 경우 하나의 조건만 사용가능 (단일행);

    * 사번이 7521의 업무와 같고, 급여가 7934보다 많은 직원의 사번, 이름, 업무, 급여를 조회
    SELECT job FROM emp WHERE empno=7521; SALESMAN
    SELECT sal FROM emp WHERE empno= 7934; 1300
    SELECT empno, ename, job, sal FROM emp WHERE job='SALESMAN' AND sal > 1300;

    SELECT empno, ename, job, sal FROM emp
    WHERE job = (SELECT job FROM emp WHERE empno=7521)
    AND sal > (SELECT sal FROM emp WHERE empno= 7934);

    * 업무별 최소급여를 받는 직원의 이름, 급여, 부서번호, 업무를 조회
    SELECT min(sal) FROM emp GROUP BY job;

    SELECT ename, sal, deptno, job FROM emp 
    WHERE sal = 800 or sal = 1250 or sal = 5000 or sal = 2450 or sal = 3000;

    SELECT ename, sal, deptno, job FROM emp 
    WHERE sal IN(SELECT min(sal) FROM emp GROUP BY job);
                min(sal)은 5개의 비교값이 있어서 다중행= in 성립; >는 불가;

    * 업무별 최소급여보다 많이 받는 직원의 이름, 급여, 부서번호, 업무를 조회
    SELECT ename, sal, deptno, job FROM emp
    WHERE SAL > ANY (SELECT min(sal) from emp GROUP BY job);

    * 업무별 최대 급여 이상 받는 직원의 이름, 급여, 부서번호, 업무를 조회
    SELECT ename, sal, deptno, job FROM emp
    WHERE SAL >= ALL (SELECT MAX(sal) from emp GROUP BY job);

    *MILLER의 데이터 수정
    SELECT sal, comm FROM emp
    WHERE ename= 'MILLER'; --1300,NULL;

    UPDATE emp 
    SET sal= 1500, comm= 300
    WHERE ename= 'MILLER';

    UPDATE EMP
    SET SAL=1300, COMM=NULL
    WHERE ename= 'MILLER';

    SELECT empno, ename, deptno, sal, COMM FROM emp
    WHERE sal IN(SELECT sal FROM EMP WHERE DEPTNO=30)
    AND COMM IN (SELECT COMM FROM EMP WHERE DEPTNO=30);
    * 위 명령어가 안된다는걸 보여주기 위해 업데이트를 했다가 다시 원상복구;


    * 급여와 보너스가 30번 부서에 있는 직원의 급여와 보너스가 같은 직원에 대해 사번, 이름, 
      부서번호, 급여 보너스를 조회
      SELECT empno, ename, deptno, sal, COMM FROM emp
      WHERE (sal,COMM) IN(SELECT sal,COMM FROM EMP WHERE DEPTNO=30);

    * 적어도 한명의 직원으로부터 보고를 받을 수 있는 직원의 이름, 업무, 입사일자, 급여를 조회
        SELECT ename, job, hiredate, sal
        FROM emp
        WHERE empno IN(SELECT DISTINCT mgr FROM emp WHERE mgr IS NOT NULL);

        SELECT empno, ename, job, hiredate, sal 
        FROM emp e
        WHERE exists(SELECT * FROM emp WHERE e.empno=mgr); 상관 Sub Query;
            구별하기 위해 별명 생성(e); 별명 있는 것이 상관 서브쿼리;
            exists= 존재하면 조건 실행, 없으면 그냥 넘어감;

    * 가장 최근에 입사한 직원의 이름, 부서, 업무, 입사일자 조회
        SELECT ename, deptno, job, hiredate
        FROM emp 
        WHERE HIREDATE IN(SELECT MAX(HIREDATE) FROM EMP);

        SELECT rownum, ename, deptno, job, hiredate
        FROM (SELECT*FROM emp ORDER BY hiredate DESC)
        WHERE rownum = 1; 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡs
        SELECT ename, deptno, job, hiredate
        FROM emp
        WHERE ROWNUM <= 5; 가장 처음 상위 5개의 행만 가져옴;

        SELECT ename, deptno, job, hiredate
        FROM emp
        WHERE ROWNUM = 1
        ORDER BY HIREDATE DESC;  ROWNUM이 먼저라 내가원하는데로 안나오는 명령어

    * INLINE VIEW
        SELECT rownum, ename, deptno, job, hiredate
        FROM (SELECT*FROM emp ORDER BY hiredate DESC)
        WHERE rownum = 1; 
        EMP 대신 INLINE 요소로 ORDER BY를 집어넣었음; 먼저 정렬 후 최상위 데이터 수집
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

7.JOIN
    (1) 여러 개의 테이블을 병합하여 하나의 결과를 도출하기 위한 방법
    (2) 종류
        1) Cartesian Product Join(Cross Join)
        2) Equi Join
            - 공통 필드의 레코드를 가져오는 방법 (중복)
            - INNER JOIN (Natural Join): 중복 제거
            - 같은 조인 데이터 요건이 있어야 성립됨;
        3) OUTER JOIN
            - INNER JOIN 확장: INNER JOIN + 공통되지 않는 레코드도 가져옴
            - 종류
                LEFT OUTER JOIN
                    - 왼쪽 것 테이블 데이터 가져오고 난 다음 겹치는 것 가져옴
                RIGHT OUTER JOIN
                    - 겹치는 데이터 가져온 다음 오른쪽 테이블 데이터 가져옴
                FULL OUTER JOIN
                    - 양쪽 테이블 데이터 전부 가져옴
        4) Non Equi Join
            - 공통되지 않은 레코드를 가져오는 방법
        5) SELF JOIN
            - 서로 같은 테이블 내에서 조인
            - 같은 테이블 2개로 해서 뽑아내야할 자료가 있을 때 사용

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

* 실습
    - test1으로 접속
    - 테이블 생성
        CREATE TABLE tblA(id number, value number);
        CREATE TABLE tblB(id number, value number);
        CREATE TABLE tblC(id number, value number);

        INSERT INTO tblA VALUES(1,10);
        INSERT INTO tblA VALUES(2,20);
        INSERT INTO tblA VALUES(3,30);
        INSERT INTO tblA VALUES(5,50);
        INSERT INTO tblA VALUES(7,70);

        INSERT INTO tblB VALUES(1,10);
        INSERT INTO tblB VALUES(2,20);
        INSERT INTO tblB VALUES(4,40);
        INSERT INTO tblB VALUES(5,50);
        INSERT INTO tblB VALUES(8,80);

        INSERT INTO tblC VALUES(1,10);
        INSERT INTO tblC VALUES(2,20);
        INSERT INTO tblC VALUES(7,70);
        INSERT INTO tblC VALUES(8,80);
        INSERT INTO tblC VALUES(9,90);

    - INNER JOIN
        SELECT tblA.id, tblA.value FROM TBLA INNER JOIN TBLB
        ON TBLA.id = TBLB.id; INNER은 안써도 호환됨/ 겹치는 요소만 불러옴

        SELECT a.id, b.value FROM TBLA a INNER JOIN TBLB b
        ON a.id = b.id;
            별명을 줘서 가독성 높이기;

        SELECT a.id, b.value FROM TBLA a, TBLB b
        WHERE a.id = b.id; 비표준 문법
        , 일떄는 ON이 아니라 WHERE;

     - scott으로 접속
        직원의 사번, 이름, 업무, 부서번호, 부서명 조회
        SELECT empno, ename, job, e.deptno, dname
        FROM emp e JOIN DEPT d
        ON e.DEPTNO = d.DEPTNO;
        입력데이터 사이에 조인 데이터 요건이 있다면 어느소속 데이터인지 명확히 입력해야됨;

        SALESMAN에 대해서 사번, 이름, 업무, 부서명 조회
        SELECT EMPNO, ENAME, JOB, dname
        FROM EMP e JOIN DEPT d
        ON e.DEPTNO = d.DEPTNO 
        AND JOB = 'SALESMAN';
        AND같은 경우 동시에 함

        AND와 WHERE 현재는 입력값이 같지만 상황에 따라 달라질 수 있음;

        SELECT EMPNO, ENAME, JOB, dname
        FROM EMP e JOIN DEPT d
        ON e.DEPTNO = d.DEPTNO
        WHERE JOB = 'SALESMAN';
        WHERE같은 경우 ON절이 끝나고 실행;

    - test1으로 접속
        SELECT a.ID, a.VALUE FROM tblA a, tblB b;

    - OUTER JOIN
        - test1으로 접속
        SELECT a.id, a.value, b.id, b.value 
        FROM tblA a LEFT OUTER JOIN tblB b
        ON a.id = b.id; 왼쪽

        SELECT a.id, a.value, b.id, b.value 
        FROM tblA a RIGHT OUTER JOIN tblB b
        ON a.id = b.id; 오른쪽

        SELECT a.id, a.value, b.id, b.value 
        FROM tblA a FULL OUTER JOIN tblB b
        ON a.id = b.id; 전부

        - 비표준 문법
        SELECT a.id, a.value FROM tblA a, tblB b
        WHERE a.id = b.id(+);

        SELECT a.id, a.value FROM tblA a, tblB b
        WHERE a.id(+) = b.id;
            비표준에서 FULL은 필요없어서 준비안함;

        - scott으로 접속
        이름, 급여, 부서명, 근무지를 조회하시오
        단, 부서명과 근무지는 모두 출력할 수 있도록 하시오.
        SELECT ename, sal, dname, loc
        FROM emp RIGHT OUTER JOIN dept
        ON emp.deptno = dept.deptno;

    - Non Equi Join
        - scott으로 접속
        * 직원들의 급여에 대한 등급을 조회
        SELECT ename, job, sal, grade
        FROM emp INNER JOIN salgrade
        ON sal >= losal and sal <= hisal;
            디비설계에 따라 사용 방법이 달라짐;

    - Self Join
    * 직원의 사번, 이름, 업무, 관리자, 관리자명을 조회
    SELECT e1.empno, e1.ename, e1.job, e1.mgr, e2.ename as 관리자명
    FROM EMP e1 INNER JOIN EMP e2
    ON e1.mgr = e2.empno;
        관리자 명이 사번이랑 같아야 해서 같은 테이블 2개가 필요했음;
        입력값 데이터의 소속감은 확실하게 배치;

    - 3개 테이블을 조인
        - test1으로 접속
        SELECT tblA.id, tblA.value
        FROM tblA JOIN tblB
        ON tblA.id = tblB.id
        INNER JOIN tblC
        ON tblB.id = tblC.id;
        
        - 3개의 테이블에서 교집합 -> 입력값

        - 비표준 문법
        SELECT tblA.id, tblA.value
        FROM tblA, tblB, tblC
        WHERE tblA.id = tblB.id AND tblB.id = tblC.id;

8. Transaction
    (1) 개념 및 특징
        1) Transaction이란 데이터베이스 내에서 하나의 그룹으로 처리되어야 
           하는 명령문(dml)들을 모아 놓은 작업 단위
        2) 데이터의 일관성과 무결성을 보장하기 위해 반드시 트랜젝션 관리가 
           필요
        3) All or Nothing
        4) 동기화(Synchronize)
            - 한번에 한가지 일만 수행하게끔; 이 일이 끝나고 다음 일로 넘어감
            - 속도가 느려짐
            - 한 사용자가 일을 끝내기전까지 다른 사용자가 그 일을 사용x

    (2) 명령어
        1) rollback
        2) commit
        3) savepoint, begin transaction, and transaction, ...

9. Data Integrity
    (1) What? how?
        1) 실체(Entity) 무결성
            - 중복된 데이터 방지
            - Primary Key, Unique
        2) 영역 무결성
            - 범위
            - Check
        3) 참조 무결성
            - 참조
            - Foreign Key

    (2) 컬럼의 특성
        1) NN(NOT NULL)
            - Primary Key
            - not null
            - default

        2) ND(No Duplicate)
            - Primary Key; 중복을 막아줌
            - Unique
                - 중복 방지
                - 하나의 테이블에 여러개 사용 가능
            - Sequence

        3) NC
            - Foreign Key
                - 참조 하고 있을 경우 참조 당하는 컬럼은 수정 불가;
            ALTER TABLE EMP ADD CONSTRAINT FK_DEPTNO FOREIGN KEY(DEPTNO)
            REFERENCES DEPT(DEPTNO);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

    * 테이블 작성
        CREATE TABLE tblExam(
            id    number  not null,
            name    varchar2(10)
        );

         CREATE TABLE TBLEXAM(
            ID  NUMBER,
            NAME   VARCHAR2(10),
            GENDER   CHAR(1),
            ADDR   VARCHAR2(20),
            CONSTRAINT PK_ID PRIMARY KEY(ID,NAME)
            ID와 NAME을 같이 묶어서 주키로 설정가능
            위와 같은 형태가 가장 이상적인 형태;
        );
        CONSTRAINT; 제약 조건, 무기;

    * Primary Key
        - 하나의 테이블에 단 한개만 사용 가능
        - 여러개의 필드를 묶어서 설정 가능

        INSERT INTO tblExam(name) VALUES('홍길동');
        INSERT INTO tblExam VALUES(1,'홍길동');
        INSERT INTO tblExam VALUES(1,'홍길동');

    * 테이블 구조 수정법
        ALTER TABLE tblExam ADD CONSTRAINT pk_id PRIMARY KEY(id);
        주키 추가;

        ALTER TABLE tblExam ADD AGE NUMBER NOT NULL;
        새로운 컬럼 추가;

        ALTER TABLE tblExam MODIFY NAME VARCHAR(20) NOT NULL;
        기존 컬럼 수정법; MODIFY

        ALTER TABLE tblExam DROP COLUMN age;
        컬럼 삭제;

        DROP TABLE TBLEXAM;

        ALTER TABLE TBLEXAM DROP CONSTRAINT PK_ID;
        기본키 삭제하는 방법;

    * Unique
        DROP TABLE tblExam;
        CREATE TABLE tblExam(
            id    number   not null,
            name   varchar2(10),
            tel    varchar2(15),
            CONSTRAINT uk_id UNIQUE(ID),
            CONSTRAINT uk_tel UNIQUE(tel)
        );

        INSERT INTO tblExam VALUES(1,'홍길동',NULL);
        INSERT INTO tblExam VALUES(2,'홍길동',NULL);

    * DEFAULT
        DROP TABLE tblExam;
         CREATE TABLE tblExam(
            id    number   not null,
            name   varchar2(10) default '무명씨',
            point    number default 0          
        );

        INSERT INTO TBLEXAM(ID) VALUES(1);

    * Sequence 
        CREATE SEQUENCE seq_num; 주석처리
        CREATE SEQUENCE seq_num START WITH 2 INCREMENT BY 1;

        INSERT INTO tblExam VALUES(seq_num.nextVal,'홍길동',10);
        INSERT INTO tblExam VALUES(seq_num.nextVal,'임꺽정',10);
        INSERT INTO tblExam VALUES(seq_num.nextVal,'TOM',10);

    * DD(Data Dictionary)
        SELECT constraint_name, table_name FROM USER_CONSTRAINTS;

    * CHECK
        DROP TABLE tblExam;
        CREATE TABLE tblExam(
            id    number,
            name    varchar2(10),
            city    varchar2(10),
            age     number
        );

        ALTER TABLE tblExam 
        ADD CONSTRAINT ck_city CHECK (city IN('서울','경기'));

        INSERT INTO tblExam VALUES(seq_num.nextVal, '홍길동','서울',20);
        INSERT INTO tblExam VALUES(seq_num.nextVal, 'TOM','경기',60);

    * 나이를 20 ~ 60세까지만 입력받을 수 있게 제약 추가
    ALTER TABLE tblExam 
    ADD CONSTRAINT ck_age CHECK (age BETWEEN 20 AND 60);

    * Foreign Key
        CREATE TABLE DEPT(
            DEPTNO CHAR(3),
            DNAME VARCHAR2(10)
        );

        ALTER TABLE DEPT ADD CONSTRAINT PK_DEPTNO PRIMARY KEY(DEPTNO);

        ALTER TABLE DEPT MODIFY DNAME VARCHAR2(20);

        INSERT INTO DEPT VALUES('100','영업부');
        INSERT INTO DEPT VALUES('110','마케팅부');

        CREATE TABLE EMP(
            EMPNO   NUMBER,
            ENMAE VARCHAR2(20),
            HIREDATE  DATE,
            DEPTNO  CHAR(3)
        );

        ALTER TABLE EMP ADD CONSTRAINT FK_DEPTNO FOREIGN KEY(DEPTNO)
        REFERENCES DEPT(DEPTNO);
        
        INSERT INTO EMP VALUES(1, 'TOM', SYSDATE, '100');
        INSERT INTO EMP VALUES(2, 'JERRY', SYSDATE, '150');

        UPDATE DEPT
        SET deptno='200'
        WHERE deptno='100'; 불가

10. VIEW
    (1) 물리적인 테이블을 근거로 하는 논리적인 가상 테이블

11. INDEX

12. Stored Procedure

13. Trigger

14. DB 설계(모델링)
